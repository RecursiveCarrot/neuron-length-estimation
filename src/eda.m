getd = @(p)path(p,path);

figure(1)
original = imread('../sample/patch02.tif');
n = length(original);
N = n*n;
imshow(original), title('Original Patch Image');
text(size(original,2),size(original,1),...
     'Why is it so blurry', ...
     'FontSize',7,'HorizontalAlignment','right');

figure(2)
imgroup({original(:,:,1) original(:,:,2) original(:,:,3)}, {'R' 'G' 'B'}, 1,3);

[mask, colormasked_img] = createMask(original);
lab_img = rgb2lab(original);
gray_img = 255-rgb2gray(original);

figure(3)
pca_img = original;
double_img = im2double(pca_img);
m = mean(mean(pca_img,1), 2);
X = reshape(double_img - repmat(m, [n n 1]), [n*n 3] );
C = (X'*X)/N;
[V,D] = eig(C); D = diag(D);
[D,I] = sort(D, 'descend'); V = V(:,I);
applymat = @(f,T)reshape( reshape(f, [n*n 3])*T, [n n 3] );
rgb2pca = @(f,V,m)applymat(f - repmat(m, [n n 1]),V);
pca_img = rgb2pca(double_img,V,m);
clf;
imgroup({pca_img(:,:,1) pca_img(:,:,2) pca_img(:,:,3)}, {'PCA_1' 'PCA_2' 'PCA_3'}, 1,3);

figure(4)
imshowpair(pca_img(:,:,3), original,'montage')

figure(5)
% doubles_img = im2double(original);
doubles_img = pca_img;
net = denoisingNetwork('DnCNN');
net_denoised_R = denoiseImage(doubles_img(:,:,1), net);
net_denoised_G = denoiseImage(doubles_img(:,:,2), net);
net_denoised_B = denoiseImage(doubles_img(:,:,3), net);
net_denoised_img = cat(3,net_denoised_R, net_denoised_G, net_denoised_B);
sep = net_denoised_img(:,:,1)-doubles_img(:,:,1);
imgroup({net_denoised_img(:,:,1) doubles_img(:,:,1) ... 
    net_denoised_img(:,:,2) doubles_img(:,:,2) ... 
    net_denoised_img(:,:,3) doubles_img(:,:,3)}, ...
    {'PCA_1' 'PCA_2' 'PCA_3' 'PCA_1' 'PCA_2' 'PCA_3'}, 2,3);

figure(6)
imgroup({ sep }, {'Noise'}, 1, 1)

figure(7)
wiener_denoisedz_img = wiener2(original(:,:,2),[5 5]);
imshowpair(wiener_denoised_img, original(:,:,2), 'montage')


%ab = lab_img(:,:,2:3);
%ab = im2single(ab);

%nColors = 2;
%pixel_labels = imsegkmeans(ab,nColors,'NumAttempts',3);

%imshow(pixel_labels,[])
%title('Image Labeled by Cluster Index');

%mask1 = pixel_labels==2;
%cluster1 = original .* uint8(mask1);
% imshowpair(gray, original,'montage')
%title('Objects in Each Cluster');

% img = 255-rgb2gray(img);

% J = imbinarize(img,0.4);
% J0 = imbinarize(imgaussfilt(img,0.1),0.3);
% J2 = bwskel(J0);
% imtool(img)
% figure(1)
% imshowpair(img,J2)
% 
% figure(2)
% imshowpair(img,J2,'montage')


function [BW,maskedRGBImage] = createMask(RGB)
%createMask  Threshold RGB image using auto-generated code from colorThresholder app.
%  [BW,MASKEDRGBIMAGE] = createMask(RGB) thresholds image RGB using
%  auto-generated code from the colorThresholder app. The colorspace and
%  range for each channel of the colorspace were set within the app. The
%  segmentation mask is returned in BW, and a composite of the mask and
%  original RGB images is returned in maskedRGBImage.

% Auto-generated by colorThresholder app on 03-Oct-2018
%------------------------------------------------------


% Convert RGB image to chosen color space
I = rgb2hsv(RGB);

% Define thresholds for channel 1 based on histogram settings
channel1Min = 0.150;
channel1Max = 0.501;

% Define thresholds for channel 2 based on histogram settings
channel2Min = 0.000;
channel2Max = 1.000;

% Define thresholds for channel 3 based on histogram settings
channel3Min = 0.000;
channel3Max = 1.000;

% Create mask based on chosen histogram thresholds
sliderBW = (I(:,:,1) >= channel1Min ) & (I(:,:,1) <= channel1Max) & ...
    (I(:,:,2) >= channel2Min ) & (I(:,:,2) <= channel2Max) & ...
    (I(:,:,3) >= channel3Min ) & (I(:,:,3) <= channel3Max);
BW = sliderBW;

% Initialize output masked image based on input image.
maskedRGBImage = RGB;

% Set background pixels where BW is false to zero.
maskedRGBImage(repmat(~BW,[1 1 3])) = 0;

end